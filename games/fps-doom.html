<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOOM-LIKE FPS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        #mainCanvas {
            border: 2px solid #ff0000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin-top: 10px;
            color: #0f0;
            font-size: 18px;
            background: #111;
            padding: 10px;
            border: 2px solid #0f0;
        }
        .hud-section {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #weaponDisplay {
            font-size: 24px;
            color: #ff0;
        }
        #healthBar, #armorBar, #ammoBar {
            width: 150px;
            height: 20px;
            background: #333;
            border: 2px solid #0f0;
            position: relative;
        }
        .bar-fill {
            height: 100%;
            transition: width 0.3s;
        }
        #healthBar .bar-fill { background: #f00; }
        #armorBar .bar-fill { background: #00f; }
        #ammoBar .bar-fill { background: #ff0; }
        #messages {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #f00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            text-align: center;
        }
        #minimap {
            position: fixed;
            top: 10px;
            right: 10px;
            border: 2px solid #0f0;
        }
        .tutorial {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #0f0;
            font-size: 14px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #0f0;
        }
        #gameOver {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border: 4px solid #f00;
            color: #f00;
            text-align: center;
            font-size: 32px;
        }
        .btn {
            background: #f00;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        .btn:hover {
            background: #ff3333;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="mainCanvas" width="800" height="600"></canvas>
        <div id="hud">
            <div class="hud-section">
                <div>HEALTH: <span id="healthText">100</span></div>
                <div id="healthBar"><div class="bar-fill" style="width: 100%"></div></div>
            </div>
            <div class="hud-section">
                <div>ARMOR: <span id="armorText">0</span></div>
                <div id="armorBar"><div class="bar-fill" style="width: 0%"></div></div>
            </div>
            <div class="hud-section">
                <div>WEAPON: <span id="weaponDisplay">PISTOL</span></div>
                <div>AMMO: <span id="ammoText">∞</span></div>
                <div id="ammoBar"><div class="bar-fill" style="width: 100%"></div></div>
            </div>
            <div class="hud-section">
                <div>KILLS: <span id="killCount">0</span></div>
                <div>LEVEL: <span id="levelNum">1</span></div>
                <div>SCORE: <span id="score">0</span></div>
            </div>
        </div>
    </div>
    <canvas id="minimap" width="150" height="150"></canvas>
    <div id="messages"></div>
    <div class="tutorial">
        WASD - Move | Mouse - Look | Click - Shoot<br>
        1-4 - Switch Weapons | E - Use/Pickup<br>
        ESC - Pause
    </div>
    <div id="gameOver">
        <div id="gameOverText">YOU ARE DEAD</div>
        <div style="font-size: 20px; margin-top: 20px;">Final Score: <span id="finalScore"></span></div>
        <button class="btn" onclick="location.reload()">RESTART</button>
    </div>

    <script>
        // Game constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const FOV = Math.PI / 3;
        const MAX_DEPTH = 20;
        const MOVE_SPEED = 0.05;
        const ROT_SPEED = 0.03;

        // Canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d');

        // Game state
        let player = {
            x: 1.5,
            y: 1.5,
            angle: 0,
            health: 100,
            armor: 0,
            weapon: 'pistol',
            ammo: { pistol: Infinity, shotgun: 20, chaingun: 100, rocket: 5 },
            kills: 0,
            score: 0
        };

        let keys = {};
        let mouseX = 0;
        let enemies = [];
        let items = [];
        let projectiles = [];
        let level = 1;
        let isPaused = false;

        // Weapons
        const weapons = {
            pistol: { damage: 15, fireRate: 300, spread: 0.05, ammoType: 'pistol', name: 'PISTOL' },
            shotgun: { damage: 10, fireRate: 600, spread: 0.2, pellets: 7, ammoType: 'shotgun', name: 'SHOTGUN' },
            chaingun: { damage: 8, fireRate: 100, spread: 0.08, ammoType: 'chaingun', name: 'CHAINGUN' },
            rocket: { damage: 100, fireRate: 1000, spread: 0, splash: 2, ammoType: 'rocket', name: 'ROCKET' }
        };

        let lastShot = 0;
        let canShoot = true;

        // Map (1 = wall, 0 = empty, 2 = exit)
        let map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,1,1,0,0,0,0,1,1,1,0,0,1],
            [1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1,0,2,1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
            [1,0,0,1,1,1,0,0,0,0,1,1,1,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Initialize enemies and items
        function initLevel() {
            enemies = [];
            items = [];
            projectiles = [];

            // Spawn enemies
            const numEnemies = 3 + level * 2;
            for (let i = 0; i < numEnemies; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * (map[0].length - 2)) + 1;
                    y = Math.floor(Math.random() * (map.length - 2)) + 1;
                } while (map[y][x] !== 0 || distance(player.x, player.y, x + 0.5, y + 0.5) < 3);

                enemies.push({
                    x: x + 0.5,
                    y: y + 0.5,
                    health: 30 + level * 10,
                    speed: 0.02 + level * 0.005,
                    damage: 10 + level * 2,
                    lastAttack: 0,
                    state: 'patrol'
                });
            }

            // Spawn items
            const itemTypes = ['health', 'armor', 'ammo_shotgun', 'ammo_chaingun', 'ammo_rocket'];
            for (let i = 0; i < 5; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * (map[0].length - 2)) + 1;
                    y = Math.floor(Math.random() * (map.length - 2)) + 1;
                } while (map[y][x] !== 0);

                items.push({
                    x: x + 0.5,
                    y: y + 0.5,
                    type: itemTypes[Math.floor(Math.random() * itemTypes.length)]
                });
            }
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // Raycasting
        function castRay(angle) {
            let sin = Math.sin(angle);
            let cos = Math.cos(angle);

            for (let depth = 0; depth < MAX_DEPTH; depth += 0.1) {
                let x = player.x + cos * depth;
                let y = player.y + sin * depth;

                let mapX = Math.floor(x);
                let mapY = Math.floor(y);

                if (mapX < 0 || mapX >= map[0].length || mapY < 0 || mapY >= map.length) {
                    return { depth, wall: 1, exit: false };
                }

                if (map[mapY][mapX] === 1) {
                    return { depth, wall: 1, exit: false };
                }

                if (map[mapY][mapX] === 2) {
                    return { depth, wall: 2, exit: true };
                }
            }

            return { depth: MAX_DEPTH, wall: 0, exit: false };
        }

        // Render 3D view
        function render3D() {
            // Floor and ceiling
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT / 2);
            ctx.fillStyle = '#222';
            ctx.fillRect(0, CANVAS_HEIGHT / 2, CANVAS_WIDTH, CANVAS_HEIGHT / 2);

            // Cast rays
            for (let x = 0; x < CANVAS_WIDTH; x++) {
                let rayAngle = (player.angle - FOV / 2) + (x / CANVAS_WIDTH) * FOV;
                let ray = castRay(rayAngle);

                // Fix fish-eye effect
                let correctedDepth = ray.depth * Math.cos(rayAngle - player.angle);
                let wallHeight = (CANVAS_HEIGHT / correctedDepth) * 0.5;

                // Wall color based on distance and type
                let brightness = Math.max(20, 255 - correctedDepth * 20);
                if (ray.exit) {
                    ctx.fillStyle = `rgb(0, ${brightness}, 0)`;
                } else {
                    ctx.fillStyle = `rgb(${brightness}, ${brightness * 0.3}, ${brightness * 0.3})`;
                }

                ctx.fillRect(x, (CANVAS_HEIGHT - wallHeight) / 2, 1, wallHeight);
            }

            // Render enemies
            enemies.forEach(enemy => {
                let dx = enemy.x - player.x;
                let dy = enemy.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let angle = Math.atan2(dy, dx) - player.angle;

                // Normalize angle
                while (angle < -Math.PI) angle += 2 * Math.PI;
                while (angle > Math.PI) angle -= 2 * Math.PI;

                if (Math.abs(angle) < FOV / 2 && dist < MAX_DEPTH) {
                    let size = (CANVAS_HEIGHT / dist) * 0.3;
                    let x = (angle / FOV + 0.5) * CANVAS_WIDTH - size / 2;
                    let y = CANVAS_HEIGHT / 2 - size / 2;

                    // Enemy sprite (simple red circle with eyes)
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(x + size / 2, y + size / 2, size / 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.fillRect(x + size * 0.3, y + size * 0.3, size * 0.15, size * 0.15);
                    ctx.fillRect(x + size * 0.55, y + size * 0.3, size * 0.15, size * 0.15);

                    // Health bar
                    let healthPercent = enemy.health / (30 + level * 10);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(x, y - 10, size * healthPercent, 5);
                }
            });

            // Render items
            items.forEach(item => {
                let dx = item.x - player.x;
                let dy = item.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let angle = Math.atan2(dy, dx) - player.angle;

                while (angle < -Math.PI) angle += 2 * Math.PI;
                while (angle > Math.PI) angle -= 2 * Math.PI;

                if (Math.abs(angle) < FOV / 2 && dist < MAX_DEPTH) {
                    let size = (CANVAS_HEIGHT / dist) * 0.15;
                    let x = (angle / FOV + 0.5) * CANVAS_WIDTH - size / 2;
                    let y = CANVAS_HEIGHT / 2 - size / 2;

                    // Item color based on type
                    switch (item.type) {
                        case 'health':
                            ctx.fillStyle = '#f00';
                            ctx.fillText('+', x, y);
                            break;
                        case 'armor':
                            ctx.fillStyle = '#00f';
                            break;
                        default:
                            ctx.fillStyle = '#ff0';
                    }
                    ctx.fillRect(x, y, size, size);
                }
            });

            // Weapon display
            ctx.fillStyle = '#888';
            ctx.fillRect(CANVAS_WIDTH / 2 - 50, CANVAS_HEIGHT - 150, 100, 100);
            ctx.fillStyle = '#000';
            ctx.font = '20px Courier New';
            ctx.fillText(weapons[player.weapon].name.slice(0, 3), CANVAS_WIDTH / 2 - 20, CANVAS_HEIGHT - 90);

            // Crosshair
            ctx.strokeStyle = canShoot ? '#0f0' : '#f00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(CANVAS_WIDTH / 2 - 10, CANVAS_HEIGHT / 2);
            ctx.lineTo(CANVAS_WIDTH / 2 + 10, CANVAS_HEIGHT / 2);
            ctx.moveTo(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 10);
            ctx.lineTo(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 10);
            ctx.stroke();
        }

        // Render minimap
        function renderMinimap() {
            minimapCtx.fillStyle = '#000';
            minimapCtx.fillRect(0, 0, 150, 150);

            let scale = 150 / map.length;

            // Draw map
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[0].length; x++) {
                    if (map[y][x] === 1) {
                        minimapCtx.fillStyle = '#888';
                        minimapCtx.fillRect(x * scale, y * scale, scale, scale);
                    } else if (map[y][x] === 2) {
                        minimapCtx.fillStyle = '#0f0';
                        minimapCtx.fillRect(x * scale, y * scale, scale, scale);
                    }
                }
            }

            // Draw enemies
            minimapCtx.fillStyle = '#f00';
            enemies.forEach(e => {
                minimapCtx.fillRect(e.x * scale - 2, e.y * scale - 2, 4, 4);
            });

            // Draw player
            minimapCtx.fillStyle = '#0f0';
            minimapCtx.fillRect(player.x * scale - 3, player.y * scale - 3, 6, 6);

            // Draw direction
            minimapCtx.strokeStyle = '#0f0';
            minimapCtx.beginPath();
            minimapCtx.moveTo(player.x * scale, player.y * scale);
            minimapCtx.lineTo(
                player.x * scale + Math.cos(player.angle) * 10,
                player.y * scale + Math.sin(player.angle) * 10
            );
            minimapCtx.stroke();
        }

        // Update HUD
        function updateHUD() {
            document.getElementById('healthText').textContent = Math.max(0, player.health);
            document.getElementById('armorText').textContent = player.armor;
            document.getElementById('weaponDisplay').textContent = weapons[player.weapon].name;

            let ammo = player.ammo[player.weapon];
            document.getElementById('ammoText').textContent = ammo === Infinity ? '∞' : ammo;

            document.getElementById('killCount').textContent = player.kills;
            document.getElementById('levelNum').textContent = level;
            document.getElementById('score').textContent = player.score;

            document.querySelector('#healthBar .bar-fill').style.width = Math.max(0, player.health) + '%';
            document.querySelector('#armorBar .bar-fill').style.width = Math.min(100, player.armor) + '%';

            if (ammo !== Infinity) {
                let maxAmmo = { shotgun: 50, chaingun: 200, rocket: 20 }[player.weapon];
                document.querySelector('#ammoBar .bar-fill').style.width = (ammo / maxAmmo * 100) + '%';
            } else {
                document.querySelector('#ammoBar .bar-fill').style.width = '100%';
            }
        }

        // Show message
        function showMessage(text, duration = 2000) {
            let msg = document.getElementById('messages');
            msg.textContent = text;
            setTimeout(() => msg.textContent = '', duration);
        }

        // Shoot
        function shoot() {
            if (!canShoot) return;

            let weapon = weapons[player.weapon];
            let ammo = player.ammo[player.weapon];

            if (ammo === 0) {
                showMessage('OUT OF AMMO!', 1000);
                return;
            }

            canShoot = false;
            setTimeout(() => canShoot = true, weapon.fireRate);

            if (ammo !== Infinity) {
                player.ammo[player.weapon]--;
            }

            // Check hits
            let pellets = weapon.pellets || 1;
            for (let i = 0; i < pellets; i++) {
                let spread = (Math.random() - 0.5) * weapon.spread;
                let angle = player.angle + spread;

                enemies.forEach(enemy => {
                    let dx = enemy.x - player.x;
                    let dy = enemy.y - player.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    let enemyAngle = Math.atan2(dy, dx);

                    if (Math.abs(enemyAngle - angle) < 0.1 && dist < MAX_DEPTH) {
                        enemy.health -= weapon.damage;
                        if (enemy.health <= 0) {
                            player.kills++;
                            player.score += 100 * level;
                            showMessage('KILL! +' + (100 * level), 1000);
                        }
                    }
                });
            }

            // Remove dead enemies
            enemies = enemies.filter(e => e.health > 0);
        }

        // Enemy AI
        function updateEnemies(deltaTime) {
            enemies.forEach(enemy => {
                let dx = player.x - enemy.x;
                let dy = player.y - enemy.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 8) {
                    enemy.state = 'chase';

                    // Move towards player
                    let moveX = (dx / dist) * enemy.speed;
                    let moveY = (dy / dist) * enemy.speed;

                    let newX = enemy.x + moveX;
                    let newY = enemy.y + moveY;

                    if (map[Math.floor(newY)][Math.floor(newX)] === 0) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }

                    // Attack if close
                    if (dist < 1 && Date.now() - enemy.lastAttack > 1000) {
                        enemy.lastAttack = Date.now();
                        let damage = enemy.damage;
                        if (player.armor > 0) {
                            player.armor -= damage / 2;
                            damage /= 2;
                            if (player.armor < 0) {
                                damage += Math.abs(player.armor);
                                player.armor = 0;
                            }
                        }
                        player.health -= damage;
                        showMessage('HIT! -' + Math.floor(damage), 1000);

                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                }
            });
        }

        // Pickup items
        function checkItems() {
            items = items.filter(item => {
                let dist = distance(player.x, player.y, item.x, item.y);
                if (dist < 0.5) {
                    switch (item.type) {
                        case 'health':
                            player.health = Math.min(100, player.health + 25);
                            showMessage('+25 HEALTH');
                            break;
                        case 'armor':
                            player.armor = Math.min(100, player.armor + 25);
                            showMessage('+25 ARMOR');
                            break;
                        case 'ammo_shotgun':
                            player.ammo.shotgun += 10;
                            showMessage('+10 SHOTGUN AMMO');
                            break;
                        case 'ammo_chaingun':
                            player.ammo.chaingun += 50;
                            showMessage('+50 CHAINGUN AMMO');
                            break;
                        case 'ammo_rocket':
                            player.ammo.rocket += 3;
                            showMessage('+3 ROCKETS');
                            break;
                    }
                    player.score += 10;
                    return false;
                }
                return true;
            });
        }

        // Check exit
        function checkExit() {
            let mapX = Math.floor(player.x);
            let mapY = Math.floor(player.y);

            if (map[mapY][mapX] === 2 && enemies.length === 0) {
                level++;
                player.score += 500;
                showMessage('LEVEL COMPLETE! +500', 3000);
                setTimeout(() => {
                    initLevel();
                }, 2000);
            } else if (map[mapY][mapX] === 2) {
                showMessage('KILL ALL ENEMIES FIRST!', 2000);
            }
        }

        // Game over
        function gameOver() {
            document.getElementById('finalScore').textContent = player.score;
            document.getElementById('gameOver').style.display = 'block';
            isPaused = true;
        }

        // Game loop
        let lastTime = Date.now();
        function gameLoop() {
            if (isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            let now = Date.now();
            let deltaTime = now - lastTime;
            lastTime = now;

            // Movement
            let moveSpeed = keys['Shift'] ? MOVE_SPEED * 2 : MOVE_SPEED;

            if (keys['w'] || keys['W']) {
                let newX = player.x + Math.cos(player.angle) * moveSpeed;
                let newY = player.y + Math.sin(player.angle) * moveSpeed;
                if (map[Math.floor(newY)][Math.floor(newX)] !== 1) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys['s'] || keys['S']) {
                let newX = player.x - Math.cos(player.angle) * moveSpeed;
                let newY = player.y - Math.sin(player.angle) * moveSpeed;
                if (map[Math.floor(newY)][Math.floor(newX)] !== 1) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys['a'] || keys['A']) {
                let newX = player.x + Math.cos(player.angle - Math.PI / 2) * moveSpeed;
                let newY = player.y + Math.sin(player.angle - Math.PI / 2) * moveSpeed;
                if (map[Math.floor(newY)][Math.floor(newX)] !== 1) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys['d'] || keys['D']) {
                let newX = player.x + Math.cos(player.angle + Math.PI / 2) * moveSpeed;
                let newY = player.y + Math.sin(player.angle + Math.PI / 2) * moveSpeed;
                if (map[Math.floor(newY)][Math.floor(newX)] !== 1) {
                    player.x = newX;
                    player.y = newY;
                }
            }

            // Rotation with keys
            if (keys['ArrowLeft']) player.angle -= ROT_SPEED;
            if (keys['ArrowRight']) player.angle += ROT_SPEED;

            // Update game state
            updateEnemies(deltaTime);
            checkItems();
            if (keys['e'] || keys['E']) {
                checkExit();
                keys['e'] = false;
                keys['E'] = false;
            }

            // Render
            render3D();
            renderMinimap();
            updateHUD();

            requestAnimationFrame(gameLoop);
        }

        // Input handlers
        document.addEventListener('keydown', e => {
            keys[e.key] = true;

            // Weapon switching
            if (e.key === '1') player.weapon = 'pistol';
            if (e.key === '2' && player.ammo.shotgun > 0) player.weapon = 'shotgun';
            if (e.key === '3' && player.ammo.chaingun > 0) player.weapon = 'chaingun';
            if (e.key === '4' && player.ammo.rocket > 0) player.weapon = 'rocket';

            if (e.key === 'Escape') {
                isPaused = !isPaused;
                showMessage(isPaused ? 'PAUSED' : 'RESUMED');
            }
        });

        document.addEventListener('keyup', e => {
            keys[e.key] = false;
        });

        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
            shoot();
        });

        document.addEventListener('mousemove', e => {
            if (document.pointerLockElement === canvas) {
                player.angle += e.movementX * 0.002;
            }
        });

        // Start game
        initLevel();
        gameLoop();
    </script>
</body>
</html>
